にうむ、純関数（戦略カーネル）**だけ**を“変更ゼロで増やせる”前提で、DDD構成に沿って**配置・責務・完全コード**をまとめたよ。調査面では、**Functional Core / Imperative Shell** と **Hexagonal（Ports & Adapters）** の原則、そして **vectorbt の `Portfolio.from_signals` 契約**を根拠としている（下に出典）。この方針なら、新しい指標・インジを増やしても**純関数は不変**にできます。([destroyallsoftware.com][1], [alistair.cockburn.us][2], [alistaircockburn.com][3], [AWS ドキュメント][4], [vectorbt.dev][5])

# どこに置くか（DDD/Hexagonalの配置）

* 既定ツリーの **src3: 戦略カーネル** に純関数を配置：
  `trade_app/apps/kernel/decide.py`（1ファイル/400行以内）。
  ここは**YAMLもフレームワークも知らない**“値だけ”の世界。アダプタ（src4, adapters）がYAMLを**features（列）**と**plan（DSL/実行計画）**に翻訳し、純関数に**値で渡す**。

```mermaid
flowchart LR
  subgraph spec["Spec(YAML)"]
    yy["\"指標・閾値・演算プリミティブ\""]
  end
  subgraph adapters["src4 変換層/Adapters"]
    y2f["\"YAML→features(DataFrame/配列)\""]
    y2p["\"YAML→plan(DSL/AST)\""]
  end
  subgraph core["src3 純関数カーネル"]
    dec["decide(o,h,l,c, features, plan)\n→ entries/short_entries/exits\n※ 指標名やYAMLは知らない"]
  end
  subgraph exec["実行側"]
    vbt["vectorbt: Portfolio.from_signals(price=open, ...)"]
  end
  yy --> y2f --> y2p --> dec --> vbt
```

* **依存方向**：司令塔 → 変換層 → 純関数 → vbt/MT5。純関数へ**外部仕様を逆流させない**のがコツ（Hexagonalのポート命名/多アダプタ許容思想に一致）。([alistaircockburn.com][3], [alistair.cockburn.us][2], [AWS ドキュメント][4])

---

# 純関数の完全コード（決定的・副作用なし・400行以内）

以下をそのまま `trade_app/apps/kernel/decide.py` に置いてね。
**要点**：

* 入力は **OHLC** と **features（列名→配列）** と **plan（演算プリミティブの列挙）** だけ。
* **DSLは最小集合**（`gt/le/between/cross_over/cross_under/not/and/or/shift`）。
* **vectorbt 実行契約に寄せた出力**：`entries`, `exits`, `short_entries`, `short_exits`（ブール配列）。`price=open` での実行を前提に、**前バー判定→次バーOpen執行**のための `pre_shift_bars` に対応。([vectorbt.dev][5])

```python
# trade_app/apps/kernel/decide.py
# -*- coding: utf-8 -*-
"""
純関数カーネル（Functional Core）
- 役割: OHLC と features(列) と plan(DSL/実行計画) を受け取り、
        entries / exits / short_entries / short_exits のブール配列を返す。
- 責務: 値の変換/判定のみ。外部I/O・YAMLパース・フレームワーク依存なし。
- 契約: vectorbt の from_signals と整合するシグナル形式（price=open を推奨）。
        前バー判定→次バーOpen執行のため pre_shift_bars=1 をデフォルトに持つ。

Plan(DSL)例:
plan = {
  "pre_shift_bars": 1,                  # 判定→執行のラグ（通常1）
  "entry": { "logic": "all", "rules": [  # all / any
      {"op": "gt", "a": "rsi", "b": 30},
      {"op": "cross_over", "a": "ma_fast", "b": "ma_slow"}
  ]},
  "exit":  { "logic": "any", "rules": [
      {"op": "lt", "a": "rsi", "b": 50}
  ]},
  "short_entry": { "logic": "all", "rules": [
      {"op": "lt", "a": "rsi", "b": 70}
  ]},
  "short_exit":  { "logic": "any", "rules": [
      {"op": "gt", "a": "rsi", "b": 50}
  ]}
}

ルールは入れ子にできます:
{"op":"and","rules":[ {"op":"gt","a":"atr","b":1.2}, {"op":"not","rule":{"op":"lt","a":"rsi","b":20}} ]}
{"op":"shift","rule":{"op":"gt","a":"rsi","b":30}, "n":1}  # 1本ずらす
"""
from __future__ import annotations

from typing import Any, Dict, Iterable, Mapping, MutableMapping, Optional, Sequence, Tuple, Union
import math
import numpy as np


ArrayLike = Union[np.ndarray, Sequence[float]]
BoolArray = np.ndarray
Number = Union[int, float]


# ---------------------------
# ユーティリティ（純粋・副作用なし）
# ---------------------------

def _as_array(x: ArrayLike) -> np.ndarray:
    """1D配列へ（pandas/リスト対応）。コピー最小化のため asarray。"""
    arr = np.asarray(x)
    if arr.ndim != 1:
        raise ValueError(f"Expected 1D array, got shape={arr.shape}")
    return arr


def _len_check(*arrays: ArrayLike) -> int:
    """全配列の長さが一致するか確認し、長さを返す。"""
    lens = [len(a) for a in arrays]
    if len(set(lens)) != 1:
        raise ValueError(f"Length mismatch: {lens}")
    return lens[0]


def _zeros_bool(n: int) -> BoolArray:
    return np.zeros(n, dtype=bool)


def _safe_get_feature(features: Mapping[str, ArrayLike], key: str) -> np.ndarray:
    if key not in features:
        raise KeyError(f"Feature '{key}' not found")
    return _as_array(features[key])


def _is_number(x: Any) -> bool:
    try:
        float(x)
        return True
    except Exception:
        return False


def _resolve_operand(features: Mapping[str, ArrayLike], token: Any) -> np.ndarray:
    """
    オペランド解決:
      - str 且つ features に存在 → 対応列
      - 数値 → 全要素がその値の一定配列
    """
    if isinstance(token, str) and token in features:
        return _safe_get_feature(features, token)
    if _is_number(token):
        # scalar を features 長さにブロードキャスト（後続で長さ決定）
        val = float(token)
        # 呼び出し側で長さが未確定のときがあるため遅延ブロードキャスト
        return np.array([val], dtype=float)  # 長さ1: 後で broadcast_to する
    # 未対応型はエラー
    raise ValueError(f"Unsupported operand token: {token!r}")


def _broadcast(a: np.ndarray, n: int) -> np.ndarray:
    """長さ1配列（定数）を長さnへブロードキャスト。"""
    if a.ndim != 1:
        raise ValueError("Only 1D arrays supported")
    if len(a) == n:
        return a
    if len(a) == 1:
        return np.broadcast_to(a, (n,))
    raise ValueError(f"Cannot broadcast array of length {len(a)} to {n}")


def _shift_bool(arr: BoolArray, n: int) -> BoolArray:
    """ブール配列のシフト（右方向: 未来へずらさない。n>0で「後ろへ」）。欠損は False 充填。"""
    if n == 0:
        return arr
    out = np.zeros_like(arr)
    if n > 0:
        out[n:] = arr[:-n]
    else:
        out[:n] = arr[-n:]
    return out


def _cross_over(a: np.ndarray, b: np.ndarray) -> BoolArray:
    """a が b を上抜け。先頭は False。"""
    n = _len_check(a, b)
    prev = np.zeros(n, dtype=bool)
    prev[1:] = (a[:-1] <= b[:-1])
    now = (a > b)
    out = prev & now
    out[0] = False
    return out


def _cross_under(a: np.ndarray, b: np.ndarray) -> BoolArray:
    """a が b を下抜け。先頭は False。"""
    n = _len_check(a, b)
    prev = np.zeros(n, dtype=bool)
    prev[1:] = (a[:-1] >= b[:-1])
    now = (a < b)
    out = prev & now
    out[0] = False
    return out


def _ensure_bool(arr: np.ndarray) -> BoolArray:
    if arr.dtype == bool:
        return arr
    # 0/1 や NaN 混在に優しく: 0→False, それ以外→True（NaN は False を推奨）
    out = np.zeros_like(arr, dtype=bool)
    # NaNをFalseにするため、np.nan_to_numで0に寄せ、!=0 を取る
    out = np.nan_to_num(arr, nan=0.0) != 0.0
    return out


# ---------------------------
# DSL 評価
# ---------------------------

def _eval_rule(
    o: np.ndarray, h: np.ndarray, l: np.ndarray, c: np.ndarray,
    features: Mapping[str, ArrayLike],
    rule: Mapping[str, Any],
    n_ctx: int
) -> BoolArray:
    """
    1つの rule を評価してブール配列にする。
    サポート演算子:
      - 比較: gt/ge/lt/le/eq/ne
      - 範囲: between (inclusive=True/False)
      - クロス: cross_over / cross_under
      - 否定: not
      - シフト: shift (rule, n)
      - 論理: and / or （rules: [...])
      - 特別: always_true / always_false
      - 予約語 a/b/c: オペランド（列名 or 数値）
      - 予約語 col: 'open'|'high'|'low'|'close' も a/b に置ける
    """
    op = rule.get("op")
    if op is None:
        raise ValueError("Rule must have 'op' key")

    # open/high/low/close という予約語の解決
    def _resolve(token: Any) -> np.ndarray:
        if token == "open":
            return o
        if token == "high":
            return h
        if token == "low":
            return l
        if token == "close":
            return c
        return _resolve_operand(features, token)

    if op in {"always_true", "true"}:
        return np.ones(n_ctx, dtype=bool)
    if op in {"always_false", "false"}:
        return np.zeros(n_ctx, dtype=bool)

    if op in {"gt", "ge", "lt", "le", "eq", "ne"}:
        a = _resolve(rule.get("a"))
        b = _resolve(rule.get("b"))
        n = n_ctx
        a = _broadcast(_as_array(a), n)
        b = _broadcast(_as_array(b), n)
        if op == "gt":
            return (a > b)
        if op == "ge":
            return (a >= b)
        if op == "lt":
            return (a < b)
        if op == "le":
            return (a <= b)
        if op == "eq":
            return (a == b)
        if op == "ne":
            return (a != b)

    if op == "between":
        a = _resolve(rule.get("a"))
        lo = _resolve(rule.get("lo"))
        hi = _resolve(rule.get("hi"))
        inclusive = bool(rule.get("inclusive", True))
        n = n_ctx
        a = _broadcast(_as_array(a), n)
        lo = _broadcast(_as_array(lo), n)
        hi = _broadcast(_as_array(hi), n)
        if inclusive:
            return (a >= lo) & (a <= hi)
        return (a > lo) & (a < hi)

    if op == "cross_over":
        a = _broadcast(_as_array(_resolve(rule.get("a"))), n_ctx)
        b = _broadcast(_as_array(_resolve(rule.get("b"))), n_ctx)
        return _cross_over(a, b)

    if op == "cross_under":
        a = _broadcast(_as_array(_resolve(rule.get("a"))), n_ctx)
        b = _broadcast(_as_array(_resolve(rule.get("b"))), n_ctx)
        return _cross_under(a, b)

    if op == "not":
        sub = rule.get("rule")
        if sub is None:
            raise ValueError("'not' requires 'rule'")
        return ~_eval_rule(o, h, l, c, features, sub, n_ctx)

    if op == "shift":
        sub = rule.get("rule")
        n = int(rule.get("n", 1))
        base = _eval_rule(o, h, l, c, features, sub, n_ctx)
        return _shift_bool(base, n)

    if op in {"and", "or"}:
        rules = rule.get("rules", [])
        if not isinstance(rules, Iterable) or len(rules) == 0:
            return np.zeros(n_ctx, dtype=bool)
        masks = [_eval_rule(o, h, l, c, features, r, n_ctx) for r in rules]
        out = masks[0].copy()
        for m in masks[1:]:
            out = (out & m) if op == "and" else (out | m)
        return out

    raise ValueError(f"Unsupported op: {op!r}")


def _eval_block(
    o: np.ndarray, h: np.ndarray, l: np.ndarray, c: np.ndarray,
    features: Mapping[str, ArrayLike],
    block: Optional[Mapping[str, Any]],
    n_ctx: int
) -> BoolArray:
    """
    block = {"logic": "all"|"any", "rules":[...]} を評価。
    無ければ全False。
    """
    if not block:
        return np.zeros(n_ctx, dtype=bool)
    logic = (block.get("logic") or "all").lower()
    rules = block.get("rules") or []
    if not isinstance(rules, Iterable) or len(rules) == 0:
        return np.zeros(n_ctx, dtype=bool)

    masks = [_eval_rule(o, h, l, c, features, r, n_ctx) for r in rules]
    out = masks[0].copy()
    for m in masks[1:]:
        out = (out & m) if logic == "all" else (out | m)
    return out


# ---------------------------
# 公開API（純関数）
# ---------------------------

def decide(
    o: ArrayLike,
    h: ArrayLike,
    l: ArrayLike,
    c: ArrayLike,
    features: Mapping[str, ArrayLike],
    plan: Mapping[str, Any],
) -> Dict[str, BoolArray]:
    """
    汎用・指標非依存の決定関数（純関数）

    Parameters
    ----------
    o,h,l,c : 1D array-like
        OHLC。全て同長であること。
    features : Mapping[str, 1D array-like]
        任意数の特徴量列。列名（キー）は snake_case。
    plan : Mapping
        {"pre_shift_bars": 1,
         "entry": {"logic":"all","rules":[...]},
         "exit":  {...},
         "short_entry": {...},
         "short_exit":  {...}}

    Returns
    -------
    dict[str, np.ndarray]
        {
          "entries": BoolArray,
          "exits":   BoolArray,
          "short_entries": BoolArray,
          "short_exits":   BoolArray
        }
    注意
    ----
    - 本関数は「判定」のみを担う。ポジション制御や再エントリ抑制などは
      vectorbt の from_signals 側の挙動に委ねる前提。price=open を推奨。
    """
    o_arr, h_arr, l_arr, c_arr = map(_as_array, (o, h, l, c))
    n = _len_check(o_arr, h_arr, l_arr, c_arr)

    # features の長さ検証 & ブロードキャスト（定数は長さ1→n）
    fixed_features: Dict[str, np.ndarray] = {}
    for k, v in features.items():
        arr = _as_array(v)
        arr = _broadcast(arr, n)
        fixed_features[k] = arr

    # plan
    pre_shift = int(plan.get("pre_shift_bars", 1))
    entry_blk = plan.get("entry")
    exit_blk = plan.get("exit")
    short_entry_blk = plan.get("short_entry")
    short_exit_blk = plan.get("short_exit")

    entries = _eval_block(o_arr, h_arr, l_arr, c_arr, fixed_features, entry_blk, n)
    exits = _eval_block(o_arr, h_arr, l_arr, c_arr, fixed_features, exit_blk, n)
    short_entries = _eval_block(o_arr, h_arr, l_arr, c_arr, fixed_features, short_entry_blk, n)
    short_exits = _eval_block(o_arr, h_arr, l_arr, c_arr, fixed_features, short_exit_blk, n)

    # 前バー判定→次バー Open 執行（実運用・検証で整合させるため）
    if pre_shift != 0:
        entries = _shift_bool(entries, pre_shift)
        exits = _shift_bool(exits, pre_shift)
        short_entries = _shift_bool(short_entries, pre_shift)
        short_exits = _shift_bool(short_exits, pre_shift)

    return {
        "entries": entries,
        "exits": exits,
        "short_entries": short_entries,
        "short_exits": short_exits,
    }


__all__ = ["decide"]
```

## 使い方（検証側の擬似コード）

```python
# 変換層(src4)がやる想定:
# - features = {"rsi": rsi_array, "ma_fast": ..., "ma_slow": ...}
# - plan = {...}  # 上のDSL例
signals = decide(o, h, l, c, features, plan)

# 実行側（アダプタ）:
# price=open（次足Openで執行）を徹底
pf = vbt.Portfolio.from_signals(
    price=open_price,
    entries=signals["entries"],
    exits=signals["exits"],
    short_entries=signals["short_entries"],
    short_exits=signals["short_exits"],
    # fees, slippage, size, jitted... は vbt 側へ
)
```

`from_signals` は“シグナル中心”の抽象化で、多数の内部前処理（型/放送/テンプレートなど）を経てNumbaに適した形式に変換されます。**コアはブール配列を返すだけ**にしておくと長寿命です。([vectorbt.dev][6], [vectorbt.pro][7])

---

## なぜこの形が“変更ゼロで拡張”に強いか（調査要点）

* **Functional Core / Imperative Shell**：境界は**値（features/plan）**。外界の変化（YAMLの追加、データ源の差し替え）が来ても、コアは**配列演算の組み立て**だけで済む。([destroyallsoftware.com][1])
* **Hexagonal**：同じ“ポート”（`decide` の固定シグネチャ）に対し、YAML→Plan のアダプタや DataFeed を**複数差し替え**できる。ポート命名や“For\_doing\_something”の指針にも一致。([alistaircockburn.com][3], [alistair.cockburn.us][2], [AWS ドキュメント][4])
* **vectorbt との整合**：`Portfolio.from_signals` の標準契約（entries/exits/…）へ“そのまま”載せられる。**price=open**で**前バー判定→次バー執行**を合わせると、検証と運用の乖離が最小。([vectorbt.dev][5])

---

## “gotcha” クイズ（ひっかけ注意）

1. `plan["entry"]["rules"]` に `{"op":"gt","a":"rsi","b":30}` を追加した。**featuresに `"rsi"` 列が無い**とき、純関数はどう振る舞う？
   → **KeyError** を投げる。変換層で**必ず列を用意**してから渡すこと（責務分離）。

2. `pre_shift_bars=0` にすると何が起きる？
   → **判定した同バーで執行**する形になる。多くの運用では**未来情報回避**のため `1` を推奨（Backtest/Liveの整合性確保）。([vectorbt.dev][5])

3. `cross_over("fast","slow")` の先頭要素は True になりうる？
   → **ならない**。先頭は前バーが無いので **False 固定**。

---

## 仕上げメモ

* 本モジュールは**単体テストが容易**（入力＝配列、出力＝配列、I/Oなし）。
* “追加インジ対応”は **src4（変換層）だけ**を触る：

  1. 新しい列を `features` に足す
  2. YAML→`plan` にその列を参照するルールを追加
     → **純関数は不変**（OCP達成）。
* 依存方向やディレクトリ構成は、あなたの既定ツリー（apps/kernel 他）に一致させたよ。

必要なら、この `decide()` に対応した**最小のユニットテスト雛形**や、`plan` の**Pydanticスキーマ**もすぐ出せるよ。

[1]: https://www.destroyallsoftware.com/talks/boundaries?utm_source=chatgpt.com "Boundaries"
[2]: https://alistair.cockburn.us/hexagonal-architecture?utm_source=chatgpt.com "hexagonal-architecture - Alistair Cockburn"
[3]: https://alistaircockburn.com/Hexagonal%20Budapest%2023-05-18.pdf?utm_source=chatgpt.com "Hexagonal Architecture ( Ports & Adapters )"
[4]: https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/hexagonal-architecture.html?utm_source=chatgpt.com "Hexagonal architecture pattern - AWS Prescriptive Guidance"
[5]: https://vectorbt.dev/getting-started/usage/?utm_source=chatgpt.com "Usage"
[6]: https://vectorbt.dev/api/portfolio/base/?utm_source=chatgpt.com "base"
[7]: https://vectorbt.pro/features/portfolio/?utm_source=chatgpt.com "Portfolio"
