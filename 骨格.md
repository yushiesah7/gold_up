# ──────────────────────────────────────────────────────────────────────────────
# AutoTrade POC — DDD Ports/Adapters Skeleton (MT5)
# 目的: ルール主導 (WFA→OOS→スクリーニング→アンサンブル) の YAML を入力に
#       オートトレードを起動できるアプリのための、厳密な型 & ポート/アダプタ骨格。
#       ここでは実装は一切書かず、引数/返り値と例外・責務の境界のみ定義する。
#       (実装は pass / NotImplementedError のみ)
# 注意: 1ファイル≤400行/循環依存禁止/依存は内向き (Domain←UseCase←Ports←Infra)
#       ※ 実運用ロジックは別PR/別コミットで段階導入。
# ──────────────────────────────────────────────────────────────────────────────

# ==== app/runner.py ===========================================================
# ランナー: DIコンテナ的にポートへアダプタを注入し、UCを起動する場所。

# file: app/runner.py
from __future__ import annotations

from typing import Sequence

from configs.settings import AppSettings
from domain.models.spec import LiveSpec
from ports.broker_port import BrokerPort
from ports.marketdata_port import MarketDataPort
from ports.clock_port import ClockPort
from ports.registry_port import RegistryPort
from ports.logger_port import LoggerPort
from usecase.start_autotrade_uc import StartAutoTradeUC


class AppRunner:
    """アプリのエントリポイント。
    - 設定ロード
    - Port実装の組み立て
    - ユースケースの起動
    """

    def __init__(
        self,
        settings: AppSettings,
        broker: BrokerPort,
        marketdata: MarketDataPort,
        clock: ClockPort,
        registry: RegistryPort,
        logger: LoggerPort,
    ) -> None:
        self.settings = settings
        self.broker = broker
        self.marketdata = marketdata
        self.clock = clock
        self.registry = registry
        self.logger = logger

    def run(self) -> None:
        """アプリ全体の起動。YAMLの LiveSpec 群を取得し、自動売買を開始する。
        実処理はUseCaseへ丸投げ（本ファイルは配線のみ）。
        """
        specs: Sequence[LiveSpec] = self.registry.load_live_specs()
        uc = StartAutoTradeUC(
            broker=self.broker,
            marketdata=self.marketdata,
            clock=self.clock,
            logger=self.logger,
        )
        uc.run(specs)


# ==== configs/settings.py =====================================================
# 設定は pydantic-settings などで環境変数から安全にロードする想定（実体は未実装）。

# file: configs/settings.py
from __future__ import annotations

from pydantic import BaseModel


class AppSettings(BaseModel):
    """アプリ横断設定（ログ、リトライ、YAMLディレクトリなど）。
    将来は `pydantic_settings.BaseSettings` に置き換え可能。
    """

    yaml_dir: str
    # リトライやスリッページ上限等の将来設定はここへ


# ==== domain/models/* =========================================================
# すべて「DTO/VO/エンティティの型定義」のみ。副作用や永続化は持たない。

# file: domain/models/market.py
from __future__ import annotations

from enum import Enum
from pydantic import BaseModel, field_validator


class Timeframe(str, Enum):
    M1 = "M1"
    M5 = "M5"
    M15 = "M15"
    M30 = "M30"
    H1 = "H1"
    H4 = "H4"
    D1 = "D1"


class Symbol(BaseModel):
    value: str

    @field_validator("value")
    @classmethod
    def _non_empty(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("symbol must be non-empty")
        return v


# file: domain/models/order.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional

from pydantic import BaseModel

from .market import Symbol


class OrderSide(str, Enum):
    BUY = "buy"
    SELL = "sell"


class OrderType(str, Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"


class Price(BaseModel):
    value: float  # 絶対価格（ブローカー桁は broker_specs で扱う）


class OrderId(BaseModel):
    value: int


class PositionId(BaseModel):
    value: int


class OrderRequest(BaseModel):
    symbol: Symbol
    side: OrderSide
    order_type: OrderType
    volume: float  # ロット
    price: Optional[Price] = None  # MARKET以外で使用
    sl: Optional[Price] = None
    tp: Optional[Price] = None
    client_tag: str | None = None  # magic or comment 等の識別用


class OrderResult(BaseModel):
    success: bool
    order_id: OrderId | None = None
    position_id: PositionId | None = None
    message: str | None = None  # ブローカー返却メッセージ/エラーコードの文字列表現


class ModifyResult(BaseModel):
    success: bool
    order_id: OrderId | None = None
    message: str | None = None


class CloseResult(BaseModel):
    success: bool
    position_id: PositionId | None = None
    closed_volume: float | None = None
    message: str | None = None


class Bar(BaseModel):
    time: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float


# file: domain/models/risk.py
from __future__ import annotations

from pydantic import BaseModel, field_validator


class RiskPolicy(BaseModel):
    per_trade_risk_pct: float  # 例: 0.02

    @field_validator("per_trade_risk_pct")
    @classmethod
    def _range(cls, v: float) -> float:
        if not (0 < v <= 0.1):
            raise ValueError("per_trade_risk_pct must be (0, 0.1]")
        return v


# file: domain/models/stops.py
from __future__ import annotations

from enum import Enum
from pydantic import BaseModel


class StopMode(str, Enum):
    ATR_RR = "atr_rr"


class ATRRRSpec(BaseModel):
    atr_window: list[int]
    k_for_sl: list[float]
    rr: list[float]


# file: domain/models/ensemble.py
from __future__ import annotations

from pydantic import BaseModel


class EnsembleColumn(BaseModel):
    label: str  # 例: "thr=|rsi=14|bb=(30, 1.75)"


class EnsembleSpec(BaseModel):
    columns: list[EnsembleColumn]
    weights: dict[str, float]
    meta: dict[str, str | int | float]


# file: domain/models/spec.py
from __future__ import annotations

from pydantic import BaseModel

from .market import Symbol, Timeframe
from .stops import StopMode, ATRRRSpec
from .risk import RiskPolicy
from .ensemble import EnsembleSpec


class ExecutionSpec(BaseModel):
    order_type: str  # "market" 等
    price: str  # "nextopen" 等
    slippage_rate: float
    fees_rate: float
    size: float
    leverage: float
    init_cash: float


class SessionConstraint(BaseModel):
    timezone: str
    start: str  # "HH:MM"
    end: str    # "HH:MM"


class Constraints(BaseModel):
    session: SessionConstraint | None = None


class BrokerSpecs(BaseModel):
    digits: int
    point: float
    trade_contract_size: float
    trade_tick_value: float
    trade_tick_size: float
    volume_min: float
    volume_step: float
    trade_stops_level: int
    trade_freeze_level: int
    filling_mode: int
    spread: int


class LiveSpec(BaseModel):
    # YAMLのトップ構造をほぼそのままDTO化
    market_symbol: Symbol
    market_timeframe: Timeframe

    ensemble: EnsembleSpec
    execution: ExecutionSpec
    stops_mode: StopMode
    stops_atr_rr: ATRRRSpec | None = None

    risk: RiskPolicy
    constraints: Constraints | None = None
    broker_specs: BrokerSpecs | None = None


# ==== domain/models/events.py ================================================
from __future__ import annotations

from enum import Enum
from pydantic import BaseModel


class DomainEventType(str, Enum):
    ORDER_PLACED = "OrderPlaced"
    STOP_UPDATED = "StopUpdated"
    POSITION_CLOSED = "PositionClosed"


class DomainEvent(BaseModel):
    type: DomainEventType
    payload: dict


# ==== ports/* =================================================================
# すべて抽象。UseCase はこれだけを認識し、Infra 具体型は知らない。

# file: ports/broker_port.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Sequence

from domain.models.market import Symbol
from domain.models.order import (
    OrderRequest,
    OrderResult,
    ModifyResult,
    CloseResult,
    PositionId,
)


class BrokerCredentials:
    """ログイン資格情報。
    実体はアダプタ内でのみ使用可能 (UseCase/Domain は中身を知らない)。
    """

    def __init__(self, *, login: str, password: str, server: str) -> None:
        self.login = login
        self.password = password
        self.server = server


class BrokerPort(ABC):
    """ブローカー発注/口座インタフェース。SDK固有の語彙はここで吸収する。"""

    @abstractmethod
    def connect(self, creds: BrokerCredentials) -> None:  # MT5.initialize/login 相当
        """端末と口座へ接続。失敗時は例外を投げる。"""
        raise NotImplementedError

    @abstractmethod
    def place_order(self, req: OrderRequest) -> OrderResult:
        """発注。SL/TPは req.sl/req.tp を使用。"""
        raise NotImplementedError

    @abstractmethod
    def modify_stops(self, position_id: PositionId, *, sl: float | None, tp: float | None) -> ModifyResult:
        raise NotImplementedError

    @abstractmethod
    def close_position(self, position_id: PositionId, *, volume: float | None = None) -> CloseResult:
        raise NotImplementedError

    @abstractmethod
    def positions(self, symbol: Symbol | None = None) -> Sequence[dict]:
        """ポジション一覧（最小限の辞書。将来DTO化）。"""
        raise NotImplementedError


# file: ports/marketdata_port.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable

from domain.models.market import Symbol, Timeframe
from domain.models.order import Bar


class MarketDataPort(ABC):
    @abstractmethod
    def latest_bar(self, symbol: Symbol, timeframe: Timeframe) -> Bar:
        raise NotImplementedError

    @abstractmethod
    def stream_bars(self, symbol: Symbol, timeframe: Timeframe) -> Iterable[Bar]:
        """新バーをプッシュ/ポーリングで受け取るジェネレータ。"""
        raise NotImplementedError


# file: ports/clock_port.py
from __future__ import annotations

from abc import ABC, abstractmethod
from datetime import datetime


class ClockPort(ABC):
    @abstractmethod
    def now(self) -> datetime:  # タイムゾーンはアダプタ側で扱う
        raise NotImplementedError

    @abstractmethod
    def sleep_until(self, dt: datetime) -> None:
        raise NotImplementedError


# file: ports/registry_port.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Sequence

from domain.models.spec import LiveSpec


class RegistryPort(ABC):
    @abstractmethod
    def load_live_specs(self) -> Sequence[LiveSpec]:
        """YAML群を読み込み、厳密型 LiveSpec にマッピングして返す。"""
        raise NotImplementedError


# file: ports/logger_port.py
from __future__ import annotations

from abc import ABC, abstractmethod


class LoggerPort(ABC):
    @abstractmethod
    def info(self, msg: str) -> None:  # 最小の会話語彙
        raise NotImplementedError

    @abstractmethod
    def error(self, msg: str) -> None:
        raise NotImplementedError


# ==== usecase/* ===============================================================
# ユースケースは手続き・順序・リトライ等のアプリ制御のみを担う。

# file: usecase/start_autotrade_uc.py
from __future__ import annotations

from typing import Sequence

from domain.models.spec import LiveSpec
from ports.broker_port import BrokerPort
from ports.marketdata_port import MarketDataPort
from ports.clock_port import ClockPort
from ports.logger_port import LoggerPort


class StartAutoTradeUC:
    """ライブ仕様 (LiveSpec) 群を入力に、自動売買の主ループを開始する。
    ここでは *構造* のみ定め、動作は後続実装で埋める。
    """

    def __init__(
        self,
        *,
        broker: BrokerPort,
        marketdata: MarketDataPort,
        clock: ClockPort,
        logger: LoggerPort,
    ) -> None:
        self.broker = broker
        self.marketdata = marketdata
        self.clock = clock
        self.logger = logger

    def run(self, specs: Sequence[LiveSpec]) -> None:
        # 将来的には: 各 spec ごとにシンボル/時間帯を監視し、シグナル→発注・管理
        # いまは骨格のみ
        pass


# ==== infrastructure/adapters/* ==============================================
# 具体アダプタ。SDK/OS/ファイルの罠はここで吸収し、Port語彙に正規化する。

# file: infrastructure/adapters/mt5_broker_adapter.py
from __future__ import annotations

from ports.broker_port import BrokerPort, BrokerCredentials
from domain.models.order import OrderRequest, OrderResult, ModifyResult, CloseResult, PositionId
from domain.models.market import Symbol


class MT5BrokerAdapter(BrokerPort):
    """MetaTrader5 Python API による BrokerPort 実装（ダミー）。
    実処理は後続で実装。ここでは引数と返り値の整合のみ定義。
    """

    def connect(self, creds: BrokerCredentials) -> None:
        pass

    def place_order(self, req: OrderRequest) -> OrderResult:
        return OrderResult(success=False, message="not implemented")

    def modify_stops(self, position_id: PositionId, *, sl: float | None, tp: float | None) -> ModifyResult:
        return ModifyResult(success=False, message="not implemented")

    def close_position(self, position_id: PositionId, *, volume: float | None = None) -> CloseResult:
        return CloseResult(success=False, message="not implemented")

    def positions(self, symbol: Symbol | None = None) -> list[dict]:
        return []


# file: infrastructure/adapters/mt5_marketdata_adapter.py
from __future__ import annotations

from typing import Iterable

from ports.marketdata_port import MarketDataPort
from domain.models.market import Symbol, Timeframe
from domain.models.order import Bar


class MT5MarketDataAdapter(MarketDataPort):
    def latest_bar(self, symbol: Symbol, timeframe: Timeframe) -> Bar:
        # 実装は後続: MT5から最新バー取得
        raise NotImplementedError

    def stream_bars(self, symbol: Symbol, timeframe: Timeframe) -> Iterable[Bar]:
        # 実装は後続: ポーリング/イベントで新バーをyield
        raise NotImplementedError


# file: infrastructure/adapters/system_clock_adapter.py
from __future__ import annotations

from datetime import datetime

from ports.clock_port import ClockPort


class SystemClockAdapter(ClockPort):
    def now(self) -> datetime:
        raise NotImplementedError

    def sleep_until(self, dt: datetime) -> None:
        raise NotImplementedError


# file: infrastructure/adapters/yaml_registry_adapter.py
from __future__ import annotations

from typing import Sequence

from ports.registry_port import RegistryPort
from domain.models.spec import LiveSpec


class YAMLRegistryAdapter(RegistryPort):
    def __init__(self, *, yaml_dir: str) -> None:
        self.yaml_dir = yaml_dir

    def load_live_specs(self) -> Sequence[LiveSpec]:
        # 実装は後続: yaml_dir 配下を探索→Pydanticで厳密パース
        return []


# file: infrastructure/adapters/std_logger_adapter.py
from __future__ import annotations

from ports.logger_port import LoggerPort


class StdLoggerAdapter(LoggerPort):
    def info(self, msg: str) -> None:
        pass

    def error(self, msg: str) -> None:
        pass


# ───────────────────────────── End of Skeleton ───────────────────────────────



できます。にうむさんのWFA→OOS→スクリーニング→アンサンブル由来のYAMLを“厳密型”に落とし込み、**DDD＋Ports/Adapters**で**完全疎結合**のPOC骨格を用意しました。実装はすべて `pass`／`NotImplementedError` のみで、**引数と返り値の整合性を最優先**に設計してあります（コードは右側キャンバス「AutoTrade POC — DDD Ports/Adapters Skeleton (MT5)」にすべて配置済み）。

あなたの事前ルールとYAMLフォーマットに沿ってあります（依存は内向き、Port経由、1ファイル≤400行 など）。 また、参考YAMLのキーと意味合いを**LiveSpec**へ正規化しています。

---

# これで“何ができる？”（今回のゴール）

* **MT5 へのログイン機能がアプリ側にある/ない**どちらでもOK：

  * ある → そのまま使う（`BrokerPort.connect` を外部から呼ぶだけ）
  * ない → 将来 `MT5BrokerAdapter.connect()` に実体実装を入れるだけで差し替え可（いまは `pass`）
* **YAML（LiveSpec）群 → UseCase 起動**：`RegistryPort.load_live_specs()` が `LiveSpec` の配列を返し、`StartAutoTradeUC.run(specs)` が“運用開始”の**入口**を担います（処理は未実装、型は確定）。

---

## 1) 必要ライブラリ（候補）

> 実装を入れるときに使用。今回は“型定義のみ”なのでインストールは任意。

* **MetaTrader 5 公式Python**: `MetaTrader5`（`initialize`, `login`, `order_send` ほか）
* **設定の型安全**: `pydantic`, `pydantic-settings`（環境変数・.env対応）
* **データ**: `pandas`, `numpy`
* **日時/タイムゾーン**: `python-dateutil` / `pendulum` / `tzdata`（どれか）
* **YAML**: `PyYAML` or `ruamel.yaml`
* **ロギング/再試行**: 標準 `logging`, `tenacity`（将来、UC側に導入）
* **型**: `typing-extensions`（Pythonバージョンにより）

> 参考：`MetaTrader5` の `initialize/login/order_send/account_info` のAPI形状は上記ドキュメントに準拠しています。

---

## 2) DDDに配慮した構成（ツリー全公開）

```
src/
  app/
    runner.py                   # 依存注入とUC起動だけ（配線）
  configs/
    settings.py                 # AppSettings（後でpydantic-settingsに差替え可）
  domain/
    models/
      market.py                 # Symbol, Timeframe
      order.py                  # OrderRequest/Result/... Bar などDTO
      risk.py                   # RiskPolicy
      stops.py                  # StopMode, ATRRRSpec
      ensemble.py               # EnsembleSpec/Column
      spec.py                   # LiveSpec（YAML→厳密DTO）
      events.py                 # DomainEvent（将来の拡張用）
  ports/
    broker_port.py              # connect/place/modify/close/positions
    marketdata_port.py          # latest_bar/stream_bars
    clock_port.py               # now/sleep_until
    registry_port.py            # load_live_specs
    logger_port.py              # info/error
  usecase/
    start_autotrade_uc.py       # run(specs) の入口（実処理は今は空）
  infrastructure/
    adapters/
      mt5_broker_adapter.py     # BrokerPortのMT5版（すべてpass返し）
      mt5_marketdata_adapter.py # MarketDataPortのMT5版（NotImplemented）
      system_clock_adapter.py   # ClockPort 実装（NotImplemented）
      yaml_registry_adapter.py  # YAML→LiveSpec ローダ（空配列返し）
      std_logger_adapter.py     # LoggerPort 実装（no-op）
```

* **依存方向**：`domain ← ports ← usecase ← app/infrastructure`（内向きのみ）。Ports/Adaptersの原典に忠実です。
* \*\*戦術DDD（エンティティ/VO/集約/境界）\*\*の考え方は Microsoft Learn の整理に沿っています。

---

## 3) YAML → LiveSpec（“型”のマッピング要約）

あなたのYAML例（`market/symbol`, `timeframe`, `ensemble/*`, `execution/*`, `stops/atr_rr`, `risk/per_trade_risk_pct`, `constraints/session/*`, `broker_specs/*`…）を**LiveSpec**に正規化しています。**値の意味と運用上の解釈**については、参考資料に書かれている通りです。

* `market.symbol` → `market_symbol: Symbol`
* `market.timeframe` → `market_timeframe: Timeframe`
* `ensemble.columns/weights/meta` → `EnsembleSpec`
* `execution.*` → `ExecutionSpec`（`order_type`, `price`, `slippage_rate`, `fees_rate`, `size`, `leverage`, `init_cash`）
* `stops.mode` → `stops_mode: StopMode`（`atr_rr`を想定）
* `stops.atr_rr.*` → `stops_atr_rr: ATRRRSpec`
* `risk.per_trade_risk_pct` → `RiskPolicy`
* `constraints.session.*` → `Constraints > SessionConstraint`
* `broker_specs.*` → `BrokerSpecs`（丸め・桁・最小ロット・フィリング等）

> **注意**：MT5の`order_send`は “deviationポイント”や“filling\_mode（ブローカー依存）”など **SDK固有の罠**があるため、**Adapter内で吸収**する前提でPortに露出させていません。Unsupported filling mode のような症状はアダプタで解決します。

---

## 4) 実装なしの“超厳密インターフェイス”

* 右側キャンバスに**全ファイル**を配置（メソッドシグネチャとDTOのみ）。
* 具象アダプタ（MT5）は**すべて `pass`/固定の未実装戻り**。
* 後で実装を入れるときも**引数・返り値の型は不変**なので、迷いません。

---

## 5) 徹底的な疎結合（差し替えポイント）

* **BrokerPort**：MT5→将来 cTrader/他ブローカー等へ差し替え自由（UseCaseは無変更）。
* **MarketDataPort**：ヒストリカル/リアルタイムの切替もアダプタ差替えだけ。
* **RegistryPort**：単一YAML→**複数YAML**へは“列挙して順に回す”だけ（既に対応）。
* **ClockPort**：テスト時はFakeClockで時間制御が容易。

Hexagonal（Ports/Adapters）原則に基づき“Portの語彙に閉じる”ため、SDK更新・ブローカー移行の影響が**外側（Infra）だけで完結**します。

---

## 6) 不安ポイントと対処

1. **MT5接続の前提**（ターミナル起動/ログイン）

   * *対処*：`BrokerPort.connect()` に\*\*「端末初期化 → ログイン」\*\*の2段階を実装予定（`initialize/login`）。UseCaseは意識不要。
2. **フィリングモード/デビエーション/桁**（口座による差異）

   * *対処*：`broker_specs` をYAMLで受け、それに従い**アダプタ内で丸め・補正・例外処理**。Unsupported Filling Mode はアダプタで埋める。
3. **タイムゾーンと“nextopen”**（次足始値の厳密さ）

   * *対処*：`MarketDataPort.stream_bars()` と `ClockPort` を連携し、**新バー検知→始値取得**をアダプタで保証。UseCaseは「次足で約定」という**意図**のみを記述。
4. **設定の散逸**（環境や秘密情報）

   * *対処*：`pydantic-settings`で`.env`/環境変数から注入、`extra='forbid'`で不要キーを排除。
5. **戦術DDDの過不足**（いつAggregateを導入？）

   * *対処*：今はDTO中心でOK。状態を強く持つ瞬間（ポジション帳やリスク限度）で導入検討。指針はMicrosoft Learnに準拠。

---

## 7) アーキテクチャ図（Mermaid）

```mermaid
flowchart LR
  subgraph core["Core（内側ほど価値が高い）"]
    domain_nodes["Domain\n\"Entities/ValueObjects/DTOs\""]
    app_uc["UseCase\n\"StartAutoTradeUC.run(specs)\""]
  end
  ports_node["Ports\n\"Broker/MarketData/Clock/Registry/Logger\""]
  subgraph infra_adapters["Infra Adapters\n\"MT5/Clock/YAML/Logger\""]
    mt5_broker["MT5BrokerAdapter"]
    mt5_md["MT5MarketDataAdapter"]
    sys_clock["SystemClockAdapter"]
    yaml_reg["YAMLRegistryAdapter"]
    std_log["StdLoggerAdapter"]
  end

  domain_nodes --> app_uc --> ports_node
  mt5_broker -.implements.-> ports_node
  mt5_md -.implements.-> ports_node
  sys_clock -.implements.-> ports_node
  yaml_reg -.implements.-> ports_node
  std_log -.implements.-> ports_node
```

---

## 8) “gotcha”クイズ（実践編）

1. **Q.** MT5の `order_send` で “Unsupported Filling Mode” が返る典型原因は？
   **A.** 口座が許容する `type_filling` と不一致。**ブローカー仕様に合わせて**値を選ぶ（アダプタで吸収）。

2. **Q.** “次足始値（`price: nextopen`）で成行約定”を安全に再現するのに必要な2要素は？
   **A.** a) **新バー検知**の正確さ（MarketDataPort） b) **タイムゾーン整合**（Clock/Constraints）。

3. **Q.** `MetaTrader5` Pythonでログインする標準手順の並びは？
   **A.** `initialize()` → `login()` → 処理 → `shutdown()`。

---

## 9) 次アクションの提案（任意）

* **（最小）疎結合のまま“1手”実装するなら**：

  1. `YAMLRegistryAdapter.load_live_specs()` にYAML→Pydanticパースを実装（単体テスト可）。
  2. `SystemClockAdapter.now/sleep_until` を実装。
  3. `MT5BrokerAdapter.connect()` に `initialize/login` を実装（戻り値なし、例外送出）。
* ここまでで**配線と設定だけ**は動くため、以降は `MarketDataPort`/`place_order` を段階追加。

---

### 参考（設計根拠）

* \*\*Ports/Adapters（Hexagonal）\*\*の原典と近年の資料。
* **DDDの戦術面まとめ（MS Learn）**。
* **MT5 Python APIの公式ドキュメント**（`initialize/login/order_send/account_info`）。

---

必要なら、この骨格に**あなたの`runs/summary/*`のYAML**をそのまま読ませるサンプル（`yaml_registry_adapter.py`）から実装を足していけます。
細部のロジックは“別コミットで段階導入”の想定なので、**型はこのまま固定**でOK。ここまでで「迷いゼロ」で進められるはずです。
